/*
********************************************************************************
*			INCLUDE FILES
********************************************************************************
*/
#include"define.h"
#include"Modulation.h"
/*
********************************************************************************
* NAME:			Modulation
* PURPOSE:		调制

* Input:
modType:		调制方式：2->QPSK;4->16QAM;6->64QAM
input:			需要调制的信号
length_input:	输入信号的长度
*
* Output:
mod_symbols_rel:调制产生的符号的实部
mod_symbols_img:调制产生的符号的虚部
*
* AUTHOR:		Duck
********************************************************************************
*/
void Modulation(int modType, double *mod_symbols_rel, double *mod_symbols_img, int *input ,int length_input)
{
	int i=0;
	int j=0;
	int tempp = 0;
	double sMap_real[64]={0};
	double sMap_imag[64]={0};

	double QPSK_real[4]={0.707106781186548,0.707106781186548,-0.707106781186548,-0.707106781186548};
	double QPSK_imag[4]={0.707106781186548,-0.707106781186548,0.707106781186548,-0.707106781186548};

	double QAM_16_real[16]={0.316227766016838,0.316227766016838,0.948683298050514,0.948683298050514,0.316227766016838,
		0.316227766016838,0.948683298050514,0.948683298050514,-0.316227766016838,-0.316227766016838,
		-0.948683298050514,-0.948683298050514,-0.316227766016838,-0.316227766016838,-0.948683298050514,
		-0.948683298050514};
	double QAM_16_imag[16]={0.316227766016838,0.948683298050514,0.316227766016838,0.948683298050514,-0.316227766016838,
		-0.948683298050514,-0.316227766016838,-0.948683298050514,0.316227766016838,0.948683298050514,
		0.316227766016838,0.948683298050514,-0.316227766016838,-0.948683298050514,-0.316227766016838,
		-0.948683298050514};

	double QAM_64_real[64]={0.462910049886276,0.462910049886276,0.154303349962092,0.154303349962092,0.462910049886276,
		0.462910049886276,0.154303349962092,0.154303349962092,0.771516749810460,0.771516749810460,1.08012344973464,1.08012344973464,
		0.771516749810460,0.771516749810460,1.08012344973464,1.08012344973464,0.462910049886276,0.462910049886276,0.154303349962092,
		0.154303349962092,0.462910049886276,0.462910049886276,0.154303349962092,0.154303349962092,0.771516749810460,0.771516749810460,
		1.08012344973464,1.08012344973464,0.771516749810460,0.771516749810460,1.08012344973464,1.08012344973464,-0.462910049886276,
		-0.462910049886276,-0.154303349962092,-0.154303349962092,-0.462910049886276,-0.462910049886276,-0.154303349962092,-0.154303349962092,
		-0.771516749810460,-0.771516749810460,-1.08012344973464,-1.08012344973464,-0.771516749810460,-0.771516749810460,-1.08012344973464,
		-1.08012344973464,-0.462910049886276,-0.462910049886276,-0.154303349962092,-0.154303349962092,-0.462910049886276,-0.462910049886276,
		-0.154303349962092,-0.154303349962092,-0.771516749810460,-0.771516749810460,-1.08012344973464,-1.08012344973464,-0.771516749810460,
		-0.771516749810460,-1.08012344973464,-1.08012344973464};
	double QAM_64_imag[64]={0.462910049886276,0.154303349962092,0.462910049886276,0.154303349962092,0.771516749810460,
		1.08012344973464,0.771516749810460,1.08012344973464,0.462910049886276,0.154303349962092,0.462910049886276,0.154303349962092,
		0.771516749810460,1.08012344973464,0.771516749810460,1.08012344973464,-0.462910049886276,-0.154303349962092,-0.462910049886276,
		-0.154303349962092,-0.771516749810460,-1.08012344973464,-0.771516749810460,-1.08012344973464,-0.462910049886276,-0.154303349962092,
		-0.462910049886276,-0.154303349962092,-0.771516749810460,-1.08012344973464,-0.771516749810460,-1.08012344973464,0.462910049886276,
		0.154303349962092,0.462910049886276,0.154303349962092,0.771516749810460,1.08012344973464,0.771516749810460,1.08012344973464,
		0.462910049886276,0.154303349962092,0.462910049886276,0.154303349962092,0.771516749810460,1.08012344973464,0.771516749810460,
		1.08012344973464,-0.462910049886276,-0.154303349962092,-0.462910049886276,-0.154303349962092,-0.771516749810460,-1.08012344973464,
		-0.771516749810460,-1.08012344973464,-0.462910049886276,-0.154303349962092,-0.462910049886276,-0.154303349962092,-0.771516749810460,
		-1.08012344973464,-0.771516749810460,-1.08012344973464};

	if(modType == 2){
		memcpy(sMap_real,QPSK_real,4*sizeof(double));
		memcpy(sMap_imag,QPSK_imag,4*sizeof(double));
	}
	else if(modType == 4){
		memcpy(sMap_real,QAM_16_real,16*sizeof(double));
		memcpy(sMap_imag,QAM_16_imag,16*sizeof(double));
	}
	else if(modType == 6){
		memcpy(sMap_real,QAM_64_real,64*sizeof(double));
		memcpy(sMap_imag,QAM_64_imag,64*sizeof(double));
	}
	else{
		printf("Error at modulation's modType!");
		getch();
		exit(0);
	}
	

	if(length_input%modType != 0)
	{
		printf("Error at modulation!Can't produce interger symbols");
		getch();
		exit(0);
	}

	for (i=0; i<(length_input/modType); i++)
	{
		tempp = 0;
		for (j=0; j<modType; j++)
		{
			tempp += input[modType*i+j]<<(modType-1-j);
		}
		mod_symbols_rel[i] = sMap_real[tempp];			//modulation for each symbol
		mod_symbols_img[i] = sMap_imag[tempp];
	}	
}
/*
********************************************************************************
* NAME:				trans_pdf
* PURPOSE:			算欧式距，进而算概率

* Input:
detected_symb_rel:	需要解调的信号的实部
detected_symb_img:	需要解调的信号的虚部
symb_rel:			星座图中相应点的实部
symb_img:			星座图中相应点的虚部
gauss:				用到其中的信道噪声方差
*
* Output:
temp:				用来解调
*
* AUTHOR:			Duck
********************************************************************************
*/
double trans_pdf(double detected_symb_rel, double detected_symb_img, double symb_rel, double symb_img, double snr, int modType)//解调部分用到
{
	double temp;
	double sigma;
	double isigma;
	sigma = sqrt(0.5 / ((modType /3.0) * (pow(10.0, (snr / 10.0)))));
	isigma = 1.0 / ((sigma) * (sigma));

	temp = (detected_symb_rel-symb_rel) * (detected_symb_rel-symb_rel) + (detected_symb_img-symb_img) * (detected_symb_img-symb_img);/////////算欧式距
	temp = temp * isigma * (-0.5);
	temp = exp(temp);
	temp /= sigma * sqrt(2*PI);

	return temp;
}

/*
********************************************************************************
* NAME:				Demodulation
* PURPOSE:			解调

* Input:
bigIT:				大迭代次数-1，判断是否是首次大迭代
demodType:			解调方式。0->LogMAP;1->MaxLogMAP
lenOutput:			解调产生的LLR信号的长度
modType:			调制方式：2->QPSK;3->8PSK;4->16QAM;6-。64QAM
detected_symb_rel:	需要解调的信号的实部
detected_symb_img:	需要解调的信号的虚部
La:					解调器从译码器得来的先验信息
gauss:				噪声参数
*
* Output:
LLR:				解调器产生的信息和校验bit的软量
*
* AUTHOR:			Duck
********************************************************************************
*/
void Demodulation(int bigIT, int demodType,int lenOutput,int modType, double *LLR, double *detected_symb_rel, double *detected_symb_img, double *La, double snr)
{
	if (demodType == 0)
	{
		Demodulation_LogMAP(bigIT, lenOutput ,modType , LLR, detected_symb_rel, detected_symb_img, La, snr);
	}
	else
	{
		if (demodType == 1)
		{
			Demodulation_MaxLogMAP(bigIT, lenOutput ,modType , LLR, detected_symb_rel, detected_symb_img, La, snr);
		}
	}
}

/*
********************************************************************************
* NAME:				Demodulation_LogMAP
* PURPOSE:			Log_MAP算法解调

* Input:
bigIT:				大迭代次数
lenOutput:			解调产生的LLR信号的长度
modType:			调制方式：2->QPSK;3->8PSK;4->16QAM;6-。64QAM
detected_symb_rel:	需要解调的信号的实部
detected_symb_img:	需要解调的信号的虚部
La:					解调器从译码器得来的先验信息
gauss:				噪声参数

* Output:
LLR:				解调器产生的信息和校验bit的软量
*
* AUTHOR:			Duck
********************************************************************************
*/
void Demodulation_LogMAP(int bigIT, int lenOutput,int modType, double *LLR, double *detected_symb_rel, double *detected_symb_img, double *La, double snr )
{
	int i;
	int j;
	int k;
	int t;
	double sum1=0;
	double sum0=0;
	double mul1=0;
	double mul0=0;
	double sMap_real[64]={0};
	double sMap_imag[64]={0};

	double QPSK_real[4]={0.707106781186548,0.707106781186548,-0.707106781186548,-0.707106781186548};
	double QPSK_imag[4]={0.707106781186548,-0.707106781186548,0.707106781186548,-0.707106781186548};

	double QAM_16_real[16]={0.316227766016838,0.316227766016838,0.948683298050514,0.948683298050514,0.316227766016838,
		0.316227766016838,0.948683298050514,0.948683298050514,-0.316227766016838,-0.316227766016838,
		-0.948683298050514,-0.948683298050514,-0.316227766016838,-0.316227766016838,-0.948683298050514,
		-0.948683298050514};
	double QAM_16_imag[16]={0.316227766016838,0.948683298050514,0.316227766016838,0.948683298050514,-0.316227766016838,
		-0.948683298050514,-0.316227766016838,-0.948683298050514,0.316227766016838,0.948683298050514,
		0.316227766016838,0.948683298050514,-0.316227766016838,-0.948683298050514,-0.316227766016838,
		-0.948683298050514};

	double QAM_64_real[64]={0.462910049886276,0.462910049886276,0.154303349962092,0.154303349962092,0.462910049886276,
		0.462910049886276,0.154303349962092,0.154303349962092,0.771516749810460,0.771516749810460,1.08012344973464,1.08012344973464,
		0.771516749810460,0.771516749810460,1.08012344973464,1.08012344973464,0.462910049886276,0.462910049886276,0.154303349962092,
		0.154303349962092,0.462910049886276,0.462910049886276,0.154303349962092,0.154303349962092,0.771516749810460,0.771516749810460,
		1.08012344973464,1.08012344973464,0.771516749810460,0.771516749810460,1.08012344973464,1.08012344973464,-0.462910049886276,
		-0.462910049886276,-0.154303349962092,-0.154303349962092,-0.462910049886276,-0.462910049886276,-0.154303349962092,-0.154303349962092,
		-0.771516749810460,-0.771516749810460,-1.08012344973464,-1.08012344973464,-0.771516749810460,-0.771516749810460,-1.08012344973464,
		-1.08012344973464,-0.462910049886276,-0.462910049886276,-0.154303349962092,-0.154303349962092,-0.462910049886276,-0.462910049886276,
		-0.154303349962092,-0.154303349962092,-0.771516749810460,-0.771516749810460,-1.08012344973464,-1.08012344973464,-0.771516749810460,
		-0.771516749810460,-1.08012344973464,-1.08012344973464};
	double QAM_64_imag[64]={0.462910049886276,0.154303349962092,0.462910049886276,0.154303349962092,0.771516749810460,
		1.08012344973464,0.771516749810460,1.08012344973464,0.462910049886276,0.154303349962092,0.462910049886276,0.154303349962092,
		0.771516749810460,1.08012344973464,0.771516749810460,1.08012344973464,-0.462910049886276,-0.154303349962092,-0.462910049886276,
		-0.154303349962092,-0.771516749810460,-1.08012344973464,-0.771516749810460,-1.08012344973464,-0.462910049886276,-0.154303349962092,
		-0.462910049886276,-0.154303349962092,-0.771516749810460,-1.08012344973464,-0.771516749810460,-1.08012344973464,0.462910049886276,
		0.154303349962092,0.462910049886276,0.154303349962092,0.771516749810460,1.08012344973464,0.771516749810460,1.08012344973464,
		0.462910049886276,0.154303349962092,0.462910049886276,0.154303349962092,0.771516749810460,1.08012344973464,0.771516749810460,
		1.08012344973464,-0.462910049886276,-0.154303349962092,-0.462910049886276,-0.154303349962092,-0.771516749810460,-1.08012344973464,
		-0.771516749810460,-1.08012344973464,-0.462910049886276,-0.154303349962092,-0.462910049886276,-0.154303349962092,-0.771516749810460,
		-1.08012344973464,-0.771516749810460,-1.08012344973464};

	if(modType == 2){
		memcpy(sMap_real,QPSK_real,4*sizeof(double));
		memcpy(sMap_imag,QPSK_imag,4*sizeof(double));
	}
	else if(modType == 4){
		memcpy(sMap_real,QAM_16_real,16*sizeof(double));
		memcpy(sMap_imag,QAM_16_imag,16*sizeof(double));
	}
	else if(modType == 6){
		memcpy(sMap_real,QAM_64_real,64*sizeof(double));
		memcpy(sMap_imag,QAM_64_imag,64*sizeof(double));
	}
	else{
		printf("Error at modulation's modType!");
		getch();
		exit(0);
	}

	for (k=0; k<modType; k++)										//from MSB to LSB
	{
		for (i=0; i<(lenOutput/modType); i++)/////////////共有lenOutput/TC->sMap->m个调制产生的符号
		{
			sum1 = 0; sum0 = 0;
			for (j=0; j<(1<<modType); j++)
			{				
				mul1 = 1; mul0 = 1;
				if ((j>>(modType-k-1)) % 2 == 1)
				{
					if (bigIT != 0)
					{
						for (t=0; t<modType; t++)
						{						
							if (t != k)
							{
								if ((j>>(modType-t-1)) % 2 == 1)
								{
									mul1 *= exp(-La[modType*i+t]) / (exp(-La[modType*i+t]) + 1);
								}
								else
								{
									mul1 *= 1 / (exp(-La[modType*i+t]) + 1);
								}
							}
						}
					}
					sum1 += trans_pdf(detected_symb_rel[i], detected_symb_img[i], sMap_real[j], sMap_imag[j], snr, modType) * mul1;
				}						
				else
				{
					if (bigIT != 0)
					{
						for (t=0; t<modType; t++)
						{						
							if (t != k)
							{
								if ((j>>(modType-t-1)) % 2 == 1)
								{
									mul0 *= exp(-La[modType*i+t]) / (exp(-La[modType*i+t]) + 1);
								}
								else
								{
									mul0 *= 1 / (exp(-La[modType*i+t]) + 1);
								}
							}
						}
					}
					sum0 += trans_pdf(detected_symb_rel[i], detected_symb_img[i], sMap_real[j], sMap_imag[j], snr, modType) * mul0;
				}

			}

//			LLR[TC->sMap->m*i + k] = log(sum1/sum0);
			if ((sum1/sum0) > MAX)
			{
				LLR[modType*i + k] = log(MAX);
			}
			else
			{
				if ((sum1/sum0) < MIN)
				{
					LLR[modType*i + k] = log(MIN);
				}
				else
				{
					LLR[modType*i + k] = log(sum1/sum0);
				}
			}

			LLR[modType*i + k] *= -1;
		}
	}

}

/*
********************************************************************************
* NAME:				Demodulation_MaxLogMAP
* PURPOSE:			MAX_Log_MAP算法解调

* Input:
bigIT:				大迭代次数
lenOutput:			解调产生的LLR信号的长度
modType:			调制方式：2->QPSK;3->8PSK;4->16QAM;6-。64QAM
detected_symb_rel:	需要解调的信号的实部
detected_symb_img:	需要解调的信号的虚部
La:					解调器从译码器得来的先验信息
gauss:				噪声参数

* Output:
LLR:				解调器产生的信息和校验bit的软量
*
* AUTHOR:			Duck
********************************************************************************
*/
void Demodulation_MaxLogMAP(int bigIT, int lenOutput,int modType, double *LLR, double *detected_symb_rel, double *detected_symb_img, double *La, double snr )
{
	int i=0;
	int j=0;
	int k=0;
	int t=0;
	double sum1=0;
	double sum0=0;
	double mul1=0;
	double mul0=0;
	double temp=0;
	double sMap_real[64]={0};
	double sMap_imag[64]={0};

	double QPSK_real[4]={0.707106781186548,0.707106781186548,-0.707106781186548,-0.707106781186548};
	double QPSK_imag[4]={0.707106781186548,-0.707106781186548,0.707106781186548,-0.707106781186548};

	double QAM_16_real[16]={0.316227766016838,0.316227766016838,0.948683298050514,0.948683298050514,0.316227766016838,
		0.316227766016838,0.948683298050514,0.948683298050514,-0.316227766016838,-0.316227766016838,
		-0.948683298050514,-0.948683298050514,-0.316227766016838,-0.316227766016838,-0.948683298050514,
		-0.948683298050514};
	double QAM_16_imag[16]={0.316227766016838,0.948683298050514,0.316227766016838,0.948683298050514,-0.316227766016838,
		-0.948683298050514,-0.316227766016838,-0.948683298050514,0.316227766016838,0.948683298050514,
		0.316227766016838,0.948683298050514,-0.316227766016838,-0.948683298050514,-0.316227766016838,
		-0.948683298050514};

	double QAM_64_real[64]={0.462910049886276,0.462910049886276,0.154303349962092,0.154303349962092,0.462910049886276,
		0.462910049886276,0.154303349962092,0.154303349962092,0.771516749810460,0.771516749810460,1.08012344973464,1.08012344973464,
		0.771516749810460,0.771516749810460,1.08012344973464,1.08012344973464,0.462910049886276,0.462910049886276,0.154303349962092,
		0.154303349962092,0.462910049886276,0.462910049886276,0.154303349962092,0.154303349962092,0.771516749810460,0.771516749810460,
		1.08012344973464,1.08012344973464,0.771516749810460,0.771516749810460,1.08012344973464,1.08012344973464,-0.462910049886276,
		-0.462910049886276,-0.154303349962092,-0.154303349962092,-0.462910049886276,-0.462910049886276,-0.154303349962092,-0.154303349962092,
		-0.771516749810460,-0.771516749810460,-1.08012344973464,-1.08012344973464,-0.771516749810460,-0.771516749810460,-1.08012344973464,
		-1.08012344973464,-0.462910049886276,-0.462910049886276,-0.154303349962092,-0.154303349962092,-0.462910049886276,-0.462910049886276,
		-0.154303349962092,-0.154303349962092,-0.771516749810460,-0.771516749810460,-1.08012344973464,-1.08012344973464,-0.771516749810460,
		-0.771516749810460,-1.08012344973464,-1.08012344973464};
	double QAM_64_imag[64]={0.462910049886276,0.154303349962092,0.462910049886276,0.154303349962092,0.771516749810460,
		1.08012344973464,0.771516749810460,1.08012344973464,0.462910049886276,0.154303349962092,0.462910049886276,0.154303349962092,
		0.771516749810460,1.08012344973464,0.771516749810460,1.08012344973464,-0.462910049886276,-0.154303349962092,-0.462910049886276,
		-0.154303349962092,-0.771516749810460,-1.08012344973464,-0.771516749810460,-1.08012344973464,-0.462910049886276,-0.154303349962092,
		-0.462910049886276,-0.154303349962092,-0.771516749810460,-1.08012344973464,-0.771516749810460,-1.08012344973464,0.462910049886276,
		0.154303349962092,0.462910049886276,0.154303349962092,0.771516749810460,1.08012344973464,0.771516749810460,1.08012344973464,
		0.462910049886276,0.154303349962092,0.462910049886276,0.154303349962092,0.771516749810460,1.08012344973464,0.771516749810460,
		1.08012344973464,-0.462910049886276,-0.154303349962092,-0.462910049886276,-0.154303349962092,-0.771516749810460,-1.08012344973464,
		-0.771516749810460,-1.08012344973464,-0.462910049886276,-0.154303349962092,-0.462910049886276,-0.154303349962092,-0.771516749810460,
		-1.08012344973464,-0.771516749810460,-1.08012344973464};

	if(modType == 2){
		memcpy(sMap_real,QPSK_real,4*sizeof(double));
		memcpy(sMap_imag,QPSK_imag,4*sizeof(double));
	}
	else if(modType == 4){
		memcpy(sMap_real,QAM_16_real,16*sizeof(double));
		memcpy(sMap_imag,QAM_16_imag,16*sizeof(double));
	}
	else if(modType == 6){
		memcpy(sMap_real,QAM_64_real,64*sizeof(double));
		memcpy(sMap_imag,QAM_64_imag,64*sizeof(double));
	}
	else{
		printf("Error at modulation's modType!");
		getch();
		exit(0);
	}

	for (k=0; k<modType; k++)										//from MSB to LSB
	{
		for (i=0; i<(lenOutput/modType); i++)
		{
			sum1 = -MAX; sum0 = -MAX;
			for (j=0; j<(1<<modType); j++)
			{				
				mul1 = 0; mul0 = 0;
				if ((j>>(modType-k-1)) % 2 == 1)
				{
					if (bigIT != 0)
					{
						for (t=0; t<modType; t++)
						{						
							if (t != k)
							{
								if ((j>>(modType-t-1)) % 2 == 1)
								{
									mul1 += -La[modType*i+t];
								}
							}
						}
					}
					temp = log(trans_pdf(detected_symb_rel[i], detected_symb_img[i],  sMap_real[j], sMap_imag[j], snr, modType)) + mul1;
					if (temp > sum1)
					{
						sum1 = temp;
					}
				}						
				else
				{
					if (bigIT != 0)
					{
						for (t=0; t<modType; t++)
						{						
							if (t != k)
							{
								if ((j>>(modType-t-1)) % 2 == 1)
								{
									mul0 += -La[modType*i+t];
								}
							}
						}
					}
					temp = log(trans_pdf(detected_symb_rel[i], detected_symb_img[i],  sMap_real[j], sMap_imag[j], snr, modType)) + mul0;
					if (temp > sum0)
					{
						sum0 = temp;
					}															
				}

			}
//			LLR[modType*i + k] = (sum1 - sum0);
			if ((sum1 - sum0) > log(MAX))
			{
				LLR[modType*i + k] = log(MAX);
			}
			else
			{
				if ((sum1 - sum0) < log(MIN))
				{
					LLR[modType*i + k] = log(MIN);
				}
				else
				{
					LLR[modType*i + k] = (sum1 - sum0);
				}
			}

			LLR[modType*i + k] *= -1;

		}
	}

}

